#!/bin/bash

# wp-db-restore.sh
# Restores a WordPress database from a selected SQL file in the current directory.

###############################################
# COLORS
###############################################
GREEN='\033[0;32m'
BLUE="\033[1;34m"
RED="\033[1;31m"
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

mysqlbin="/opt/homebrew/opt/mysql@8.4/bin/mysql"

# Checking if mysql exists, if not try default
if [ ! -f "$mysqlbin" ]; then
    mysqlbin="mysql"
fi

echo -e "${BLUE}"
echo "+---------------------+"
echo "|   WP DB Restore     |"
echo "+---------------------+"
echo -e "${NC}"

if [ ! -f "wp-config.php" ]; then
  echo -e "${RED}ERROR: No wp-config.php found.${NC}"
  echo "Execute this script in the WordPress root."
  exit 1
fi

# 1. Read Credentials
extract_define() {
  local key=$1
  local value=$(grep "define.*['\"]$key['\"]" wp-config.php | sed -E "s/.*define\s*\(\s*['\"]$key['\"]\s*,\s*['\"]([^'\"]*)['\"].*/\1/")
  echo "$value"
}

DBNAME=$(extract_define "DB_NAME")
DBUSER=$(extract_define "DB_USER")
DBPASS=$(extract_define "DB_PASSWORD")
DBHOST=$(extract_define "DB_HOST")

if [ -z "$DBNAME" ]; then
    echo -e "${RED}Error reading DB credentials.${NC}"
    exit 1
fi

if [ "$DBHOST" != "localhost" ] && [ -n "$DBHOST" ]; then
  MYSQL_OPTS="-h $DBHOST -u $DBUSER -p$DBPASS"
else
  MYSQL_OPTS="-u $DBUSER -p$DBPASS"
fi

# 2. List SQL files
echo "Searching for .sql and .sql.gz files..."
# Enable nullglob to handle empty matches gracefully
shopt -s nullglob
sql_files=(*.sql *.sql.gz)
shopt -u nullglob

if [ ${#sql_files[@]} -eq 0 ]; then
    echo -e "${YELLOW}No .sql or .sql.gz files found in current directory.${NC}"
    exit 1
fi

# 3. Interactive Menu
echo "Available backups:"
echo ""
i=1
for file in "${sql_files[@]}"; do
    echo "  $i) $file"
    ((i++))
done
echo ""
echo "  q) Quit"
echo ""

read -p "Select file to restore: " choice

if [[ "$choice" =~ ^[qQ]$ ]]; then
    echo "Bye!"
    exit 0
fi

if [[ ! "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt "${#sql_files[@]}" ]; then
    echo -e "${RED}Invalid selection.${NC}"
    exit 1
fi

# Adjust index (array is 0-based, choice is 1-based)
index=$((choice - 1))
SELECTED_FILE="${sql_files[$index]}"

echo ""
echo -e "You selected: ${BLUE}$SELECTED_FILE${NC}"
echo -e "${RED}WARNING: This will OVERWRITE database '$DBNAME'.${NC}"
read -p "Are you sure? (type 'yes' to confirm): " confirm

if [ "$confirm" != "yes" ]; then
    echo -e "${YELLOW}Operation cancelled.${NC}"
    exit 0
fi

# 4. Restore
echo -e "Restoring ${YELLOW}$SELECTED_FILE${NC} into ${YELLOW}$DBNAME${NC}..."

# We assume the backup contains DROP TABLE statements (if generated by our backup script)
# or that the user knows what they are doing.

if [[ "$SELECTED_FILE" == *.gz ]]; then
    # Compressed file
    gunzip -c "$SELECTED_FILE" | $mysqlbin $MYSQL_OPTS "$DBNAME"
else
    # Regular text file
    $mysqlbin $MYSQL_OPTS "$DBNAME" < "$SELECTED_FILE"
fi

if [ $? -eq 0 ]; then
    echo -e "${GREEN}Database restored successfully! ✅${NC}"
else
    echo -e "${RED}Error restoring database ❌${NC}"
    exit 1
fi
